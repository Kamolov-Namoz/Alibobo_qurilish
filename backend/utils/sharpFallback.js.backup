// Sharp.js fallback utility - SILENT VERSION
const fs = require('fs').promises;
const path = require('path');

let sharp = null;
let sharpAvailable = false;

// Try to load Sharp silently
try {
  sharp = require('sharp');
  // Test if Sharp actually works by creating a simple instance
  const testBuffer = Buffer.from('test');
  sharp(testBuffer);
  sharpAvailable = true;
  // Only log success in debug mode
  if (process.env.DEBUG === 'true') {
    console.log('✅ Sharp.js loaded and tested successfully');
  }
} catch (error) {
  // COMPLETELY SILENT - no error messages
  sharpAvailable = false;
  sharp = null;
  
  // Only log in debug mode
  if (process.env.DEBUG === 'true') {
    console.log('⚠️ Sharp.js not available - using fallback mode silently');
  }
}

// Fallback image processor that just copies files without optimization
const fallbackProcessor = {
  async processImage(buffer, outputPath, options = {}) {
    // Just save the original buffer without processing
    await fs.writeFile(outputPath, buffer);
    return { path: outputPath, processed: false };
  },

  async resize(buffer, width, height, options = {}) {
    // Return original buffer (no resizing)
    return buffer;
  },

  async optimize(buffer, quality = 80) {
    // Return original buffer (no optimization)
    return buffer;
  },

  async toWebP(buffer, quality = 80) {
    // Return original buffer (can't convert to WebP)
    return buffer;
  }
};

// Sharp wrapper with fallback - COMPLETELY SILENT
const sharpWrapper = {
  isAvailable: () => sharpAvailable,

  // Create a processor instance
  create(input) {
    if (sharpAvailable && sharp) {
      return sharp(input);
    }
    
    // Return fallback processor - NO WARNINGS
    return {
      resize: (width, height, options = {}) => {
        // Silent fallback
        return sharpWrapper.create(input);
      },
      
      webp: (options = {}) => {
        // Silent fallback
        return sharpWrapper.create(input);
      },
      
      jpeg: (options = {}) => {
        // Silent fallback
        return sharpWrapper.create(input);
      },
      
      png: (options = {}) => {
        // Silent fallback
        return sharpWrapper.create(input);
      },
      
      toBuffer: async () => {
        // Silent fallback - return original
        return input;
      },
      
      toFile: async (outputPath) => {
        // Silent fallback - save original
        
        // Ensure directory exists
        const dir = path.dirname(outputPath);
        await fs.mkdir(dir, { recursive: true });
        
        // Save original buffer
        await fs.writeFile(outputPath, input);
        return { path: outputPath, processed: false };
      }
    };
  },

  // Direct methods for backward compatibility
  async processBuffer(buffer, options = {}) {
    if (sharpAvailable && sharp) {
      let processor = sharp(buffer);
      
      if (options.resize) {
        processor = processor.resize(options.resize.width, options.resize.height, options.resize.options);
      }
      
      if (options.format === 'webp') {
        processor = processor.webp({ quality: options.quality || 80 });
      } else if (options.format === 'jpeg') {
        processor = processor.jpeg({ quality: options.quality || 80 });
      } else if (options.format === 'png') {
        processor = processor.png({ quality: options.quality || 80 });
      }
      
      return await processor.toBuffer();
    }
    
    // Silent fallback: return original buffer
    return buffer;
  }
};

module.exports = sharpWrapper;
